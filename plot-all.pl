#!/usr/bin/env perl

use 5.010000;
use strict;
use warnings;

sub shell ($);

my $infile = "Makefile";
open my $in, $infile
    or die "Cannot open $infile for reading: $!\n";
my %files;
my @cmds;
my %seen_cmds;
my $found;
while (<$in>) {
    if (/^(FILE_\w+)\s*=\s*(\S+)/) {
        $files{$1} = $2;
    }
    if (!$found && /^bench:/) {
        $found = 1;
        next;
    }
    if ($found) {
        if (/^\S/) {
            last;
        }
        if (m{^\t\@?\#?(\./bench\d*\s.+)}) {
            my $cmd = $1;
            $cmd =~ s/\$\((FILE_\w+)\)/$files{$1}/eg;
            $cmd =~ s/\s*\#.*//;
            if (!exists $seen_cmds{$cmd}) {
                $seen_cmds{$cmd} = 1;
                push @cmds, $cmd;
                #warn $cmd, "\n";
            } else {
                die "found duplicate: $cmd";
            }
        }
    }
}
close $in;

mkdir "images" unless -d "images";

my $num_width = length scalar @cmds;
my @images;
my $i = 0;
for my $cmd (@cmds) {
    #last if $i >= 2;
    if ($cmd =~ /Tom\.\{10,25\}river/) {
        warn "Skipping slow regex $cmd\n";
        next;
    }
    my $pngfile = sprintf "images/re%0${num_width}d.png", $i;
    shell(qq{echo "$cmd" > a.txt});
    shell($cmd) for 1..1;  # just to warm up a bit
    shell("$cmd >> a.txt");
    shell("./gen-plot.pl -o $pngfile a.txt");
    push @images, $pngfile;
    $i++;
}

my $outfile = "index.html";
open my $out, ">$outfile"
    or die "Cannot open $outfile for writing: $!\n";
my $title = "Regex Engine Matching Speed Benchmark";
my $total = scalar @images;
my $now = scalar localtime;
my $system = `uname -o` . " " . `uname -m`;
$system =~ s/^\s+|\s+$//g;
print $out <<_EOC_;
<!-- generated by the plot-all.pl tool from sregex:
  https://github.com/openresty/sregex/tree/dfa/bench/plot-all.pl
-->
<html>
<head>
 <title>$title</title>
 <style>
body {
    text-align: left;
    text-align-last: left;
    width: 70%;
    margin: 2em;
}

code {
    font-family: consolas, monospace;
}

 </style>
</head>
<body>
<h1>$title</h1>
<p>This page contains benchmark results for various regex engines executing
various different regexes on variuous different input data. For total <b>$total</b>
cases are shown here.</p>
<p>You can find the original programs and data below if you want to check the details
and/or run the benchmark yourself.</a>
<p>&nbsp; &nbsp; <a href="https://github.com/openresty/sregex/tree/dfa/bench/">
https://github.com/openresty/sregex/tree/dfa/bench/</a></p>
<p>Just run the <code>make && ./plot-all.pl</code> command in that directory locally
and then open the resulting <code>./index.html</code> in your favoriate web browser.</p>
<p>The results were automatically generated at $now on $system.</p>
<dl>
_EOC_

my $cc_ver = `cc --version 2>&1|head -n1`;
print $out <<_EOC_;
  <dt>C Compiler</dt>
  <dd>$cc_ver</dd>
_EOC_

my $pcre_ver = `pcre-config --version`;
print $out <<_EOC_;
  <dt><a href="http://www.pcre.org/">PCRE</a></dt>
  <dd>$pcre_ver</dd>
_EOC_

my $pcre2_ver = `pcre2-config --version`;
print $out <<_EOC_;
  <dt><a href="http://www.pcre.org/">PCRE2</a></dt>
  <dd>$pcre2_ver</dd>
_EOC_

my $re2_rev;
my $re2_dir = "../../re2";
if (-d $re2_dir) {
    $re2_rev = `cd $re2_dir && git rev-parse HEAD` or die "Cannot get re2 git HEAD.\n";
    $re2_rev = substr $re2_rev, 0, 10;
    print $out <<_EOC_;
      <dt><a href="https://github.com/google/re2/">RE2</a></dt>
      <dd>git commit <a href="https://github.com/google/re2/commit/$re2_rev">$re2_rev</a></dd>
_EOC_
}

my $sregex_rev = `git rev-parse HEAD` or die "Cannot get sregex git HEAD.\n";
$sregex_rev = substr $sregex_rev, 0, 10;
print $out <<_EOC_;
  <dt><a href="https://github.com/openresty/sregex/tree/dfa">SRegex</a></dt>
  <dd>git commit <a href="https://github.com/openresty/sregex/commit/$sregex_rev">$sregex_rev</a></dd>
_EOC_

print $out <<_EOC_;
</dl>
_EOC_

my $i = 0;
for my $img (@images) {
    $i++;
    print $out <<_EOC_;
<h2>Case $i</h2>
<p>
<img src="$img">
</p>
_EOC_
}

print $out <<_EOC_;
</body>
</html>
_EOC_
close $out;

warn "$outfile generated.\n";

sub shell ($) {
    my $cmd = shift;
    say $cmd;
    system($cmd) == 0 or die $!;
}
