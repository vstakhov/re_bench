#!/usr/bin/env perl

use 5.010000;
use strict;
use warnings;

sub shell ($);

my $infile = "Makefile";
open my $in, $infile
    or die "Cannot open $infile for reading: $!\n";
my %files;
my @cmds;
my %seen_cmds;
my $found;
while (<$in>) {
    if (/^(FILE_\w+)\s*=\s*(\S+)/) {
        $files{$1} = $2;
    }
    if (!$found && /^bench:/) {
        $found = 1;
        next;
    }
    if ($found) {
        if (/^\S/) {
            last;
        }
        if (m{^\t\@?\#?(\./bench\d*\s.+)}) {
            my $cmd = $1;
            $cmd =~ s/\$\((FILE_\w+)\)/$files{$1}/eg;
            $cmd =~ s/\$\$/\$/g;
            $cmd =~ s/\s*\#.*//;
            if (!exists $seen_cmds{$cmd}) {
                $seen_cmds{$cmd} = 1;
                push @cmds, $cmd;
                #warn $cmd, "\n";
            } else {
                die "found duplicate: $cmd";
            }
        }
    }
}
close $in;

mkdir "images" unless -d "images";

my $num_width = length scalar @cmds;
my @images;
my @results;
my $i = 0;
for my $cmd (@cmds) {
    #last if $i >= 2;
    if ($cmd =~ /\Q[a-q][^u-z]{13}x\E/ && !$ENV{SREGEX_BENCH_RUN_SLOW}) {
        warn "Skipped regex $& since the environment SREGEX_BENCH_RUN_SLOW is unset.\n";
        next;
    }
    my $pngfile = sprintf "images/re%0${num_width}d.png", $i;
    my $txtfile = "a.txt";
    (my $tag = $cmd) =~ s/\s+(?:gcc|clang)\s*$//g;
    shell(qq{echo $tag > $txtfile});
    shell("$cmd > /dev/null") for 1..1;  # just to warm up a bit
    shell("$cmd >> $txtfile");
    shell("./gen-plot.pl -o $pngfile $txtfile");
    push @images, $pngfile;
    {
        open my $in, $txtfile or die "Cannot open $txtfile for reading: $!\n";
        my $txt = do { local $/; <$in> };
        $txt =~ s/^[^\n]+\n//s;
        $txt =~ s/^-+\n//gms;
        close $in;
        push @results, $txt;
    }
    $i++;
}

my $outfile = "index.html";
open my $out, ">$outfile"
    or die "Cannot open $outfile for writing: $!\n";
my $title = "Regex Engine Matching Speed Benchmark";
my $total = scalar @images;
my $now = scalar localtime;
print $out <<_EOC_;
<!-- generated by the plot-all.pl tool from sregex:
  https://github.com/openresty/sregex/tree/dfa/bench/plot-all.pl
-->
<html>
<head>
 <title>$title</title>
 <style>
body {
    text-align: left;
    text-align-last: left;
    width: 70%;
    margin: 2em;
}

code {
    font-family: consolas, monospace;
}

dt {
    line-height: 2em;
}
 </style>
</head>
<body>
<h1>$title</h1>

<p>This page contains benchmark results for various regex engines executing
various different regexes on variuous different input data. For total <b>$total</b>
cases are shown here.</p>

<p>This page is maintained by Yichun Zhang (agentzh) &lt;agentzh\@gmail.com&gt;.</p>

<p>Many test cases used here are taken directly from the performance test suite
maintained by the author of PCRE JIT, Zoltan Herczeg.</p>

<p>Here we only consider
regex engines and their APIs that do support full <b>sub-match capturing</b>.
</p>

<p>You can find the original programs and data below if you want to check the details
and/or run the benchmark yourself.</a>

<p>&nbsp; &nbsp; <a href="https://github.com/openresty/sregex/tree/dfa/bench/">
https://github.com/openresty/sregex/tree/dfa/bench/</a></p>

<p>Just run the <code>make && ./plot-all.pl</code> command in that directory locally
and then open the resulting <code>./index.html</code> in your favoriate web browser.</p>

<p>The results were automatically generated at $now.</p>
<dl>
_EOC_

my $system = `uname -o` . " " . `uname -m`;
$system =~ s/^\s+|\s+$//g;
print $out <<_EOC_;
  <dt>Operating Systemon</dt>
  <dd>$system</dd>
_EOC_

my $cpuinfo;
if ($^O eq 'linux') {
    $cpuinfo = `grep 'model name' /proc/cpuinfo|head -n1`;
    if (defined $cpuinfo) {
        if ($cpuinfo !~ s/^\s*model\s+name\s*:\s*//) {
            undef $cpuinfo;
        }
    }
} elsif ($^O eq 'darwin') {
    $cpuinfo = `system_profiler SPHardwareDataType`;
    if (defined $cpuinfo) {
        my ($name, $speed);
        if ($cpuinfo =~ /^\s*Processor Name\s*:\s*(\S.*)/i) {
            $name = $1;
        }
        if ($cpuinfo =~ /^\s*Process Speed\s*:\s*(\S.*)/i) {
            $speed = $1;
        }
        if (defined $name || defined $speed) {
            $cpuinfo = ($name // "") . " " . ($speed // "");
        } else {
            undef $cpuinfo;
        }
    }
}

print $out <<_EOC_;
  <dt>CPU</dt>
  <dd>$cpuinfo</dd>
_EOC_


my $cc_ver = `cc --version 2>&1|head -n1`;
print $out <<_EOC_;
  <dt>C Compiler</dt>
  <dd>$cc_ver</dd>
_EOC_

my $pcre_ver = `pcre-config --version`;
print $out <<_EOC_;
  <dt><a href="http://www.pcre.org/">PCRE</a></dt>
  <dd>$pcre_ver</dd>
_EOC_

my $pcre2_ver = `pcre2-config --version`;
print $out <<_EOC_;
  <dt><a href="http://www.pcre.org/">PCRE2</a></dt>
  <dd>$pcre2_ver</dd>
_EOC_

my $re2_rev;
my $re2_dir = "../../re2";
if (-d $re2_dir) {
    $re2_rev = `cd $re2_dir && git rev-parse HEAD` or die "Cannot get re2 git HEAD.\n";
    $re2_rev = substr $re2_rev, 0, 10;
    print $out <<_EOC_;
      <dt><a href="https://github.com/google/re2/">RE2</a></dt>
      <dd>git commit <a href="https://github.com/google/re2/commit/$re2_rev">$re2_rev</a></dd>
_EOC_
}

my $sregex_rev = `git rev-parse HEAD` or die "Cannot get sregex git HEAD.\n";
$sregex_rev = substr $sregex_rev, 0, 10;
print $out <<_EOC_;
  <dt><a href="https://github.com/openresty/sregex/tree/dfa/re.pl">SRegex DFA Prototype</a></dt>
  <dd>git commit <a href="https://github.com/openresty/sregex/commit/$sregex_rev">$sregex_rev</a></dd>
_EOC_

print $out <<_EOC_;
</dl>
_EOC_

{
    my $i = 0;
    for my $img (@images) {
        my $cmd = $cmds[$i];
        my $res = $results[$i];
        $i++;
        print $out <<_EOC_;
<h2>Case $i</h2>
<p>
<pre>
\$ $cmd
$res
</pre>
</p>
<p>
<img src="$img">
</p>
_EOC_
    }
}

print $out <<_EOC_;
</body>
</html>
_EOC_
close $out;

warn "$outfile generated.\n";

sub shell ($) {
    my $cmd = shift;
    say $cmd;
    system($cmd) == 0 or die $!;
}
